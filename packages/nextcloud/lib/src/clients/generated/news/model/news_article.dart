//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.12

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of openapi.api;

class NewsArticle {
  /// Returns a new [NewsArticle] instance.
  NewsArticle({
    this.id,
    this.guid,
    this.guidHash,
    this.url,
    this.title,
    this.author,
    this.pubDate,
    this.updatedDate,
    this.body,
    this.enclosureMime,
    this.enclosureLink,
    this.mediaThumbnail,
    this.mediaDescription,
    this.feedId,
    this.unread,
    this.starred,
    this.lastModified,
    this.rtl,
    this.fingerprint,
    this.contentHash,
  });

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? id;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? guid;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? guidHash;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? url;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? title;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? author;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? pubDate;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? updatedDate;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? body;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? enclosureMime;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? enclosureLink;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? mediaThumbnail;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? mediaDescription;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? feedId;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? unread;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? starred;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? lastModified;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? rtl;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? fingerprint;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? contentHash;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NewsArticle &&
          other.id == id &&
          other.guid == guid &&
          other.guidHash == guidHash &&
          other.url == url &&
          other.title == title &&
          other.author == author &&
          other.pubDate == pubDate &&
          other.updatedDate == updatedDate &&
          other.body == body &&
          other.enclosureMime == enclosureMime &&
          other.enclosureLink == enclosureLink &&
          other.mediaThumbnail == mediaThumbnail &&
          other.mediaDescription == mediaDescription &&
          other.feedId == feedId &&
          other.unread == unread &&
          other.starred == starred &&
          other.lastModified == lastModified &&
          other.rtl == rtl &&
          other.fingerprint == fingerprint &&
          other.contentHash == contentHash;

  @override
  int get hashCode =>
      // ignore: unnecessary_parenthesis
      (id == null ? 0 : id!.hashCode) +
      (guid == null ? 0 : guid!.hashCode) +
      (guidHash == null ? 0 : guidHash!.hashCode) +
      (url == null ? 0 : url!.hashCode) +
      (title == null ? 0 : title!.hashCode) +
      (author == null ? 0 : author!.hashCode) +
      (pubDate == null ? 0 : pubDate!.hashCode) +
      (updatedDate == null ? 0 : updatedDate!.hashCode) +
      (body == null ? 0 : body!.hashCode) +
      (enclosureMime == null ? 0 : enclosureMime!.hashCode) +
      (enclosureLink == null ? 0 : enclosureLink!.hashCode) +
      (mediaThumbnail == null ? 0 : mediaThumbnail!.hashCode) +
      (mediaDescription == null ? 0 : mediaDescription!.hashCode) +
      (feedId == null ? 0 : feedId!.hashCode) +
      (unread == null ? 0 : unread!.hashCode) +
      (starred == null ? 0 : starred!.hashCode) +
      (lastModified == null ? 0 : lastModified!.hashCode) +
      (rtl == null ? 0 : rtl!.hashCode) +
      (fingerprint == null ? 0 : fingerprint!.hashCode) +
      (contentHash == null ? 0 : contentHash!.hashCode);

  @override
  String toString() =>
      'NewsArticle[id=$id, guid=$guid, guidHash=$guidHash, url=$url, title=$title, author=$author, pubDate=$pubDate, updatedDate=$updatedDate, body=$body, enclosureMime=$enclosureMime, enclosureLink=$enclosureLink, mediaThumbnail=$mediaThumbnail, mediaDescription=$mediaDescription, feedId=$feedId, unread=$unread, starred=$starred, lastModified=$lastModified, rtl=$rtl, fingerprint=$fingerprint, contentHash=$contentHash]';

  Map<String, dynamic> toJson() {
    final _json = <String, dynamic>{};
    if (id != null) {
      _json[r'id'] = id;
    } else {
      _json[r'id'] = null;
    }
    if (guid != null) {
      _json[r'guid'] = guid;
    } else {
      _json[r'guid'] = null;
    }
    if (guidHash != null) {
      _json[r'guidHash'] = guidHash;
    } else {
      _json[r'guidHash'] = null;
    }
    if (url != null) {
      _json[r'url'] = url;
    } else {
      _json[r'url'] = null;
    }
    if (title != null) {
      _json[r'title'] = title;
    } else {
      _json[r'title'] = null;
    }
    if (author != null) {
      _json[r'author'] = author;
    } else {
      _json[r'author'] = null;
    }
    if (pubDate != null) {
      _json[r'pubDate'] = pubDate;
    } else {
      _json[r'pubDate'] = null;
    }
    if (updatedDate != null) {
      _json[r'updatedDate'] = updatedDate;
    } else {
      _json[r'updatedDate'] = null;
    }
    if (body != null) {
      _json[r'body'] = body;
    } else {
      _json[r'body'] = null;
    }
    if (enclosureMime != null) {
      _json[r'enclosureMime'] = enclosureMime;
    } else {
      _json[r'enclosureMime'] = null;
    }
    if (enclosureLink != null) {
      _json[r'enclosureLink'] = enclosureLink;
    } else {
      _json[r'enclosureLink'] = null;
    }
    if (mediaThumbnail != null) {
      _json[r'mediaThumbnail'] = mediaThumbnail;
    } else {
      _json[r'mediaThumbnail'] = null;
    }
    if (mediaDescription != null) {
      _json[r'mediaDescription'] = mediaDescription;
    } else {
      _json[r'mediaDescription'] = null;
    }
    if (feedId != null) {
      _json[r'feedId'] = feedId;
    } else {
      _json[r'feedId'] = null;
    }
    if (unread != null) {
      _json[r'unread'] = unread;
    } else {
      _json[r'unread'] = null;
    }
    if (starred != null) {
      _json[r'starred'] = starred;
    } else {
      _json[r'starred'] = null;
    }
    if (lastModified != null) {
      _json[r'lastModified'] = lastModified;
    } else {
      _json[r'lastModified'] = null;
    }
    if (rtl != null) {
      _json[r'rtl'] = rtl;
    } else {
      _json[r'rtl'] = null;
    }
    if (fingerprint != null) {
      _json[r'fingerprint'] = fingerprint;
    } else {
      _json[r'fingerprint'] = null;
    }
    if (contentHash != null) {
      _json[r'contentHash'] = contentHash;
    } else {
      _json[r'contentHash'] = null;
    }
    return _json;
  }

  /// Returns a new [NewsArticle] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static NewsArticle? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "NewsArticle[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "NewsArticle[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return NewsArticle(
        id: mapValueOfType<int>(json, r'id'),
        guid: mapValueOfType<String>(json, r'guid'),
        guidHash: mapValueOfType<String>(json, r'guidHash'),
        url: mapValueOfType<String>(json, r'url'),
        title: mapValueOfType<String>(json, r'title'),
        author: mapValueOfType<String>(json, r'author'),
        pubDate: mapValueOfType<int>(json, r'pubDate'),
        updatedDate: mapValueOfType<int>(json, r'updatedDate'),
        body: mapValueOfType<String>(json, r'body'),
        enclosureMime: mapValueOfType<String>(json, r'enclosureMime'),
        enclosureLink: mapValueOfType<String>(json, r'enclosureLink'),
        mediaThumbnail: mapValueOfType<String>(json, r'mediaThumbnail'),
        mediaDescription: mapValueOfType<String>(json, r'mediaDescription'),
        feedId: mapValueOfType<int>(json, r'feedId'),
        unread: mapValueOfType<bool>(json, r'unread'),
        starred: mapValueOfType<bool>(json, r'starred'),
        lastModified: mapValueOfType<int>(json, r'lastModified'),
        rtl: mapValueOfType<bool>(json, r'rtl'),
        fingerprint: mapValueOfType<String>(json, r'fingerprint'),
        contentHash: mapValueOfType<String>(json, r'contentHash'),
      );
    }
    return null;
  }

  static List<NewsArticle>? listFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final result = <NewsArticle>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = NewsArticle.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, NewsArticle> mapFromJson(dynamic json) {
    final map = <String, NewsArticle>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = NewsArticle.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of NewsArticle-objects as value to a dart map
  static Map<String, List<NewsArticle>> mapListFromJson(
    dynamic json, {
    bool growable = false,
  }) {
    final map = <String, List<NewsArticle>>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = NewsArticle.listFromJson(
          entry.value,
          growable: growable,
        );
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{};
}
